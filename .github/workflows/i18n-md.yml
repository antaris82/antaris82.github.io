name: i18n-md (DE → EN/FR/ES)

on:
  push:
    paths:
      - "**/*.md"
  workflow_dispatch:

jobs:
  translate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute changed Markdown
        id: diff
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ github.event.before || '' }}"
          if [ -z "$BASE" ] || [ "$BASE" = "0000000000000000000000000000000000000000" ]; then
            git ls-files "*.md" > changed.txt || true
          else
            git diff --name-only "$BASE" "${{ github.sha }}" -- "**/*.md" > changed.txt || true
          fi
          echo "Changed Markdown files:"
          cat changed.txt || true
          echo "changed<<EOF" >> "$GITHUB_OUTPUT"
          cat changed.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install minimal deps
        run: |
          npm --yes init -y
          npm pkg set type=module
          npm i unified@11 remark-parse@10 unist-util-visit@5

      - name: Add translate script (Authorization header auth, auto-endpoint switch, robust parsing)
        shell: bash
        run: |
          mkdir -p .github/scripts
          cat > .github/scripts/translate-md.mjs <<'JS'
          import fs from "fs";
          import path from "path";
          import { unified } from "unified";
          import remarkParse from "remark-parse";
          import { visit } from "unist-util-visit";

          const SOURCE_LANG = (process.env.SOURCE_LANG || "DE").toUpperCase();
          const TARGET_LANGS = (process.env.TARGET_LANGS || "en,fr,es").split(",").map(s=>s.trim()).filter(Boolean);
          const DEEPL_API_KEY = process.env.DEEPL_API_KEY || "";
          const CHANGED_LIST = (process.env.CHANGED || "").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
          let DEEPL_API_URL = process.env.DEEPL_API_URL || "https://api-free.deepl.com/v2/translate";

          const isFreeKey = DEEPL_API_KEY.endsWith(":fx");
          // Auto-correct endpoint if obvious mismatch
          if (isFreeKey && /api\.deepl\.com/.test(DEEPL_API_URL)) DEEPL_API_URL = "https://api-free.deepl.com/v2/translate";
          if (!isFreeKey && /api-free\.deepl\.com/.test(DEEPL_API_URL)) DEEPL_API_URL = "https://api.deepl.com/v2/translate";

          const SKIP_DIRS = new Set([".git","node_modules",".github"]);
          const isMd = f => f.toLowerCase().endsWith(".md");

          function listAllMd(dir="."){
            const out=[];
            for (const e of fs.readdirSync(dir,{withFileTypes:true})) {
              if (SKIP_DIRS.has(e.name)) continue;
              const p = path.join(dir, e.name);
              if (e.isDirectory()) out.push(...listAllMd(p));
              else if (isMd(p)) out.push(p);
            }
            return out;
          }

          function shouldTranslateFile(f, supLangs){
            if (!isMd(f)) return false;
            const re = new RegExp(`\\.(${supLangs.join("|")})\\.md$`, "i");
            if (re.test(f)) return false; // already a translated file
            const parts = f.split(path.sep);
            if (parts.some(p => SKIP_DIRS.has(p))) return false;
            return true;
          }

          function protectSegments(src){
            const map=[]; let i=0;
            const take = (m)=>{ const id=`§§X${i++}§§`; map.push({id,content:m}); return id; };
            let out=src;
            out=out.replace(/```[\s\S]*?```/g, m=>take(m));
            out=out.replace(/~~~[\s\S]*?~~~/g, m=>take(m));
            out=out.replace(/`[^`\n]+`/g, m=>take(m));
            out=out.replace(/\$\$[\s\S]*?\$\$/g, m=>take(m));
            out=out.replace(/\\\[([\s\S]*?)\\\]/g, m=>take(m));
            out=out.replace(/\\\(([\s\S]*?)\\\)/g, m=>take(m));
            return {text: out, map};
          }
          function restoreSegments(txt,map){
            let out=txt;
            for (const {id,content} of map) out=out.split(id).join(content);
            return out;
          }

          function collectTextNodes(md){
            const tree = unified().use(remarkParse).parse(md);
            const nodes=[];
            visit(tree, (node, index, parent) => {
              if (node.type !== "text") return;
              if (parent && ["code","inlineCode","html"].includes(parent.type)) return;
              const val = node.value;
              if (!val || !val.trim()) return;
              const pos = node.position || {};
              if (typeof pos.start?.offset !== "number" || typeof pos.end?.offset !== "number") return;
              nodes.push({start: pos.start.offset, end: pos.end.offset, text: val});
            });
            return nodes;
          }

          const headers = () => ({
            "Authorization": `DeepL-Auth-Key ${DEEPL_API_KEY}`,
            "Content-Type": "application/json"
          });

          function baseUrlOf(endpoint){
            const m = endpoint.match(/^(https?:\/\/[^/]+)(?:\/.*)?$/i);
            return m ? m[1] : "https://api-free.deepl.com";
          }

          async function preflight(endpoint){
            if (!DEEPL_API_KEY) return { ok: false, status: 0, fatal: false, reason: "no-key" };
            const url = baseUrlOf(endpoint) + "/v2/usage";
            const r = await fetch(url, { headers: headers(), method: "GET" });
            return { ok: r.ok, status: r.status, fatal: r.status === 401 || r.status === 403 };
          }

          async function deeplBatchJSON(texts, targetLang, endpoint){
            const url = endpoint;
            const body = JSON.stringify({
              text: texts,
              source_lang: SOURCE_LANG,
              target_lang: targetLang.toUpperCase(),
              preserve_formatting: true
            });
            const r = await fetch(url, { method: "POST", headers: headers(), body });
            if (!r.ok) {
              const e = await r.text().catch(()=>r.statusText);
              throw new Error(`DeepL HTTP ${r.status}: ${e}`);
            }
            const j = await r.json();
            const out = j.translations?.map(x=>x.text) || [];
            return out;
          }

          async function translateFile(srcPath, endpoint){
            const raw = fs.readFileSync(srcPath, "utf8");
            const {text: protectedText, map: segMap} = protectSegments(raw);

            let nodes=[];
            try { nodes = collectTextNodes(protectedText); } catch(e){ nodes=[]; }

            if (nodes.length) {
              for (const L of TARGET_LANGS){
                const texts = nodes.map(n=>n.text);
                const outTexts = await deeplBatchJSON(texts, L, endpoint);
                if (outTexts.length !== texts.length) throw new Error("Translation batch size mismatch");

                let out = protectedText;
                const rep = nodes.map((n,i)=>({...n, newText: outTexts[i]})).sort((a,b)=> b.start - a.start);
                for (const r of rep) {
                  out = out.slice(0, r.start) + r.newText + out.slice(r.end);
                }
                out = restoreSegments(out, segMap);

                const dstPath = srcPath.replace(/\.md$/i, `.${L}.md`);
                fs.mkdirSync(path.dirname(dstPath), {recursive:true});
                fs.writeFileSync(dstPath, out, "utf8");
                console.log("→", dstPath);
              }
              return;
            }

            // Fallback: whole doc
            for (const L of TARGET_LANGS){
              const outTexts = await deeplBatchJSON([protectedText], L, endpoint);
              let out = outTexts[0] || protectedText;
              out = restoreSegments(out, segMap);
              const dstPath = srcPath.replace(/\.md$/i, `.${L}.md`);
              fs.mkdirSync(path.dirname(dstPath), {recursive:true});
              fs.writeFileSync(dstPath, out, "utf8");
              console.log("→", dstPath);
            }
          }

          (async()=>{
            if (!DEEPL_API_KEY) {
              console.log("[i18n] No DEEPL_API_KEY → skipping translation without failing.");
              return;
            }

            const supLangs = TARGET_LANGS.map(x=>x.toLowerCase());
            const candidates = (CHANGED_LIST.length? CHANGED_LIST : listAllMd(".")).filter(f=>shouldTranslateFile(f, supLangs));
            if (!candidates.length) { console.log("[i18n] No Markdown files to translate."); return; }

            // Preflight & endpoint auto-switch on 401/403
            let endpoint = DEEPL_API_URL;
            let pf = await preflight(endpoint);
            if (!pf.ok && pf.fatal) {
              const alt = /api-free\.deepl\.com/.test(endpoint) ? "https://api.deepl.com/v2/translate" : "https://api-free.deepl.com/v2/translate";
              console.warn(`[i18n] Preflight ${pf.status} on ${baseUrlOf(endpoint)} → trying ${baseUrlOf(alt)} instead.`);
              const pf2 = await preflight(alt);
              if (pf2.ok) endpoint = alt;
              else {
                console.error(`[i18n] Authentication failed (${pf.status}/${pf2.status}). Check API key and endpoint (Free vs Pro).`);
                process.exit(1);
              }
            }

            let hadError = false;
            for (const f of candidates) {
              try {
                await translateFile(f, endpoint);
              } catch(e) {
                hadError = true;
                console.error("[i18n] Failed:", f, e.message);
              }
            }
            if (hadError) process.exit(1);
          })();
          JS

      - name: Run translation
        env:
          DEEPL_API_KEY: ${{ secrets.DEEPL_API_KEY }}
          # Use 'https://api-free.deepl.com/v2/translate' for DeepL API Free keys (ending with :fx)
          # Use 'https://api.deepl.com/v2/translate'     for DeepL API Pro keys
          DEEPL_API_URL: https://api-free.deepl.com/v2/translate
          SOURCE_LANG: DE
          TARGET_LANGS: en,fr,es
          CHANGED: ${{ steps.diff.outputs.changed }}
        run: node .github/scripts/translate-md.mjs

      - name: Commit translated files
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "i18n: update translated markdown"
          file_pattern: "**/*.en.md **/*.fr.md **/*.es.md"
