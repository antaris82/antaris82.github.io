name: readme-autogen-main

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  readme_autogen:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: generate readmes (root + changed folders)
        shell: bash
        run: |
          python - <<'PY'
          import subprocess, json, re, os, sys
          from pathlib import Path
          from datetime import date

          ROOT = Path(".").resolve()

          ROLE = {
            ".py":"code",".ipynb":"notebook",".md":"doc",".txt":"doc",
            ".csv":"data",".tsv":"data",".json":"data",".parquet":"data",
            ".png":"image",".jpg":"image",".jpeg":"image",".webp":"image",".gif":"image",
            ".pdf":"doc"
          }

          TEMPLATE = (
            "# <TITEL DES ORDNERS/PROJEKTS>\\n\\n"
            "<!-- dirindex:files:start -->\\n"
            "| Name | Größe | Typ | Rolle | Kurzbeschreibung | Tags |\\n"
            "|---|---:|---|---|---|---|\\n"
            "<!-- dirindex:files:end -->\\n\\n"
            "<!-- dirindex-json\\n{\\n"
            '  "repo": "<owner>/<repo>",\\n'
            '  "path": "<ordner/pfad>",\\n'
            '  "title": "<TITEL DES ORDNERS/PROJEKTS>",\\n'
            '  "updated": "<YYYY-MM-DD>",\\n'
            '  "status": "draft",\\n'
            '  "tags": []\\n'
            "}\\ndirindex-json -->\\n"
          )

          def run(cmd):
            return subprocess.run(cmd, text=True, capture_output=True)

          def human(n:int)->str:
            if n<1024: return f"{n} B"
            if n<1024**2: return f"{n/1024:.1f} KB"
            return f"{n/1024**2:.2f} MB"

          def scan_files(folder:Path):
            rows=[]
            for p in sorted(folder.iterdir(), key=lambda x:x.name.lower()):
              if p.is_dir() or p.name.startswith("."): 
                continue
              ext=p.suffix.lower()
              rows.append((p.name, human(p.stat().st_size), (ext[1:] if ext else "file"), ROLE.get(ext,"other")))
            return rows

          def render(template:str, meta:dict, files:list):
            import re, json
            table_lines = ["| Name | Größe | Typ | Rolle | Kurzbeschreibung | Tags |",
                           "|---|---:|---|---|---|---|"]
            for name,size,typ,role in files:
              table_lines.append(f"| {name} | {size} | {typ} | {role} |  |  |")
            table = "\\n".join(table_lines)
            t = template
            rep = {
              "<TITEL DES ORDNERS/PROJEKTS>": meta.get("title",""),
              "<owner>/<repo>": meta.get("repo",""),
              "<ordner/pfad>": meta.get("path",""),
              "<YYYY-MM-DD>": meta.get("updated", date.today().isoformat()),
            }
            for k,v in rep.items(): t = t.replace(k,v)
            t = re.sub(r"<!-- dirindex:files:start -->.*?<!-- dirindex:files:end -->",
                       "<!-- dirindex:files:start -->\\n"+table+"\\n<!-- dirindex:files:end -->", t, flags=re.S)
            t = re.sub(r"(<!-- dirindex-json\\n)(.*?)(\\ndirindex-json -->)",
                       r"\\1"+json.dumps({
                         "repo": meta.get("repo",""),
                         "path": meta.get("path",""),
                         "title": meta.get("title",""),
                         "updated": meta.get("updated", date.today().isoformat()),
                         "status": meta.get("status","draft"),
                         "tags": meta.get("tags",[]),
                         "files": [{"name": f[0], "role": f[3], "desc":"", "tags": []} for f in files]
                       }, ensure_ascii=False, indent=2)+r"\\3", t, flags=re.S)
            return t

          def ensure_readme(folder:Path):
            rel = folder.relative_to(ROOT).as_posix()
            meta_path = folder/"dirindex.meta.json"
            readme_path = folder/"README.md"

            if meta_path.exists():
              try:
                meta = json.loads(meta_path.read_text(encoding="utf-8"))
              except Exception:
                meta = {}
            else:
              repo = os.getenv("GITHUB_REPOSITORY","<owner>/<repo>")
              path_field = "/" if rel=="." else rel
              meta = {"repo": repo, "path": path_field, "title": folder.name,
                      "updated": date.today().isoformat(), "status":"draft", "tags":[]}
              meta_path.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")
              print(f"[init] created dirindex.meta.json in {path_field}")

            files = scan_files(folder)
            template_file = ROOT/"README_TEMPLATE.md"
            tpl = template_file.read_text(encoding="utf-8") if template_file.exists() else TEMPLATE
            out = render(tpl, meta, files)
            old = readme_path.read_text(encoding="utf-8") if readme_path.exists() else None
            if old == out:
              print(f"[ok] no change: {rel or '/'}"); return False
            readme_path.write_text(out, encoding="utf-8")
            print(f"[write] README.md updated: {rel or '/'}")
            return True

          def changed_dirs():
            ref = "origin/main"
            cp = run(["git","rev-parse","--verify", ref])
            base = ref if cp.returncode==0 else "main"
            diff = run(["git","diff","--name-only", f"{base}...HEAD"])
            if diff.returncode != 0: 
              return []
            paths = [p for p in diff.stdout.splitlines() if p.strip()]
            dirs = set()
            for p in paths:
              rp = (ROOT/p)
              if rp.exists():
                rel = rp.parent.relative_to(ROOT).as_posix()
                dirs.add("" if rel=="." else (rel+"/" if not rel.endswith("/") else rel))
            return sorted(dirs)

          # 1) einmalig Root
          wrote = False
          if not (ROOT/"README.md").exists():
            wrote = ensure_readme(ROOT) or wrote
          # 2) geänderte Ordner
          for d in changed_dirs():
            folder = ROOT if d=="" else (ROOT/d.rstrip("/"))
            if folder.is_dir():
              wrote = ensure_readme(folder) or wrote

          # Sanity-Check ins Log:
          p = ROOT/"README.md"
          if p.exists():
            print("\\n--- README.md (head) ---")
            print("\\n".join(p.read_text(encoding="utf-8").splitlines()[:40]))
            print("--- end ---\\n")
          else:
            print("[warn] README.md fehlt weiterhin")

          # Änderungen im Arbeitsbaum anzeigen
          st = run(["git","status","--porcelain"]).stdout.strip()
          print("\\n[status]\\n"+(st or "(clean)"))

          # Ende ohne Fehler; Commit übernimmt eigener Step
          sys.exit(0)
          PY

      - name: commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Auto: README updated"
          branch: main
