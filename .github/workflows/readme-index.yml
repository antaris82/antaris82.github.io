name: readme-autogen-main

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  readme_autogen:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: generate-readmes
        shell: bash
        run: |
          set -e

          python - <<'PY'
          import subprocess, json, re, os, sys
          from pathlib import Path
          from datetime import date

          ROOT = Path(".").resolve()

          ROLE = {".py":"code",".ipynb":"notebook",".md":"doc",".txt":"doc",
                  ".csv":"data",".tsv":"data",".json":"data",".parquet":"data",
                  ".png":"image",".jpg":"image",".jpeg":"image",".webp":"image",".gif":"image",
                  ".pdf":"doc"}

          TEMPLATE = (
            "# <TITEL DES ORDNERS/PROJEKTS>\n\n"
            "<!-- dirindex:files:start -->\n"
            "| Name | Größe | Typ | Rolle | Kurzbeschreibung | Tags |\n"
            "|---|---:|---|---|---|---|\n"
            "<!-- dirindex:files:end -->\n\n"
            "<!-- dirindex-json\n"
            "{\n"
            '  "repo": "<owner>/<repo>",\n'
            '  "path": "<ordner/pfad>",\n'
            '  "title": "<TITEL DES ORDNERS/PROJEKTS>",\n'
            '  "updated": "<YYYY-MM-DD>",\n'
            '  "status": "draft",\n'
            '  "tags": []\n'
            "}\n"
            "dirindex-json -->\n"
          )

          def run(cmd):
            return subprocess.run(cmd, text=True, capture_output=True)

          def human(n:int)->str:
            if n<1024: return f"{n} B"
            if n<1024**2: return f"{n/1024:.1f} KB"
            return f"{n/1024**2:.2f} MB"

          def scan_files(folder:Path):
            rows=[]
            for p in sorted(folder.iterdir(), key=lambda x:x.name.lower()):
              if p.is_dir() or p.name.startswith("."): continue
              ext=p.suffix.lower()
              rows.append((p.name, human(p.stat().st_size), (ext[1:] if ext else "file"), ROLE.get(ext,"other")))
            return rows

          def render(template:str, meta:dict, files:list):
            table_lines = ["| Name | Größe | Typ | Rolle | Kurzbeschreibung | Tags |",
                           "|---|---:|---|---|---|---|"]
            for name,size,typ,role in files:
              table_lines.append(f"| {name} | {size} | {typ} | {role} |  |  |")
            table = "\n".join(table_lines)
            t = template
            rep = {
              "<TITEL DES ORDNERS/PROJEKTS>": meta.get("title",""),
              "<owner>/<repo>": meta.get("repo",""),
              "<ordner/pfad>": meta.get("path",""),
              "<YYYY-MM-DD>": meta.get("updated", date.today().isoformat()),
            }
            for k,v in rep.items(): t = t.replace(k,v)
            t = re.sub(r"<!-- dirindex:files:start -->.*?<!-- dirindex:files:end -->",
                       "<!-- dirindex:files:start -->\n"+table+"\n<!-- dirindex:files:end -->", t, flags=re.S)
            t = re.sub(r"(<!-- dirindex-json\n)(.*?)(\ndirindex-json -->)",
                       r"\1"+json.dumps({
                         "repo": meta.get("repo",""),
                         "path": meta.get("path",""),
                         "title": meta.get("title",""),
                         "updated": meta.get("updated", date.today().isoformat()),
                         "status": meta.get("status","draft"),
                         "tags": meta.get("tags",[]),
                         "files": [{"name": f[0], "role": f[3], "desc":"", "tags": []} for f in files]
                       }, ensure_ascii=False, indent=2)+r"\3", t, flags=re.S)
            return t

          def commit_all(msg:str):
            subprocess.run(["git","config","user.name","dirindex-bot"], check=False)
            subprocess.run(["git","config","user.email","github-actions[bot]@users.noreply.github.com"], check=False)
            subprocess.run(["git","add","-A"], check=False)
            st = run(["git","status","--porcelain"]).stdout.strip()
            if not st:
              print("[info] nothing to commit")
              return
            subprocess.run(["git","commit","-m", msg], check=True)
            subprocess.run(["git","push"], check=True)
            print("[info] pushed")

          def ensure_readme(folder:Path):
            rel = folder.relative_to(ROOT).as_posix()
            meta_path = folder/"dirindex.meta.json"
            readme_path = folder/"README.md"

            if meta_path.exists():
              try:
                meta = json.loads(meta_path.read_text(encoding="utf-8"))
              except Exception:
                meta = {}
            else:
              repo = os.getenv("GITHUB_REPOSITORY","<owner>/<repo>")
              path_field = "/" if rel=="." else rel
              meta = {"repo": repo, "path": path_field, "title": folder.name,
                      "updated": date.today().isoformat(), "status":"draft", "tags":[]}
              meta_path.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")
              print(f"[init] created dirindex.meta.json in {path_field}")

            files = scan_files(folder)
            template_file = ROOT/"README_TEMPLATE.md"
            tpl = template_file.read_text(encoding="utf-8") if template_file.exists() else TEMPLATE
            out = render(tpl, meta, files)
            old = readme_path.read_text(encoding="utf-8") if readme_path.exists() else None
            if old == out:
              print(f"[ok] no change: {rel or '/'}"); return False
            readme_path.write_text(out, encoding="utf-8")
            print(f"[write] README.md updated: {rel or '/'}")
            return True

          # 1) Bootstrap Root-README einmalig
          root_readme = ROOT/"README.md"
          wrote = False
          if not root_readme.exists():
            wrote = ensure_readme(ROOT)

          # 2) Geänderte Ordner gegenüber main ermitteln
          def changed_dirs():
            ref = "origin/main"
            cp = run(["git","rev-parse","--verify", ref])
            base = ref if cp.returncode==0 else "main"
            diff = run(["git","diff","--name-only", f"{base}...HEAD"])
            if diff.returncode != 0: return []
            paths = [p for p in diff.stdout.splitlines() if p.strip()]
            dirs = set()
            for p in paths:
              rp = (ROOT/p)
              if rp.exists():
                rel = rp.parent.relative_to(ROOT).as_posix()
                dirs.add("" if rel=="." else (rel+"/" if not rel.endswith("/") else rel))
            return sorted(dirs)

          dirs = changed_dirs()
          for d in dirs:
            folder = ROOT if d=="" else (ROOT/d.rstrip("/"))
            if folder.is_dir() and folder.exists():
              wrote = ensure_readme(folder) or wrote

          if wrote:
            commit_all("Auto: README updated")

          PY
