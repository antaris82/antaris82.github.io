<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>antaris82 ‚Äî GitHub Pages Browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9aa4b2; --card:#10161d; --accent:#2f81f7; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font:14px/1.45 system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,sans-serif; }
    header { padding:16px 20px; border-bottom:1px solid #1e2630; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    header h1 { font-size:18px; margin:0; }
    header .path { color:var(--muted); font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    main { padding:16px 20px; display:grid; grid-template-columns: 1fr; gap:16px; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .controls input[type="text"] { background:#0e141b; color:var(--fg); border:1px solid #26303c; border-radius:8px; padding:8px 10px; min-width:280px; }
    .controls button { background:var(--accent); color:white; border:0; border-radius:8px; padding:8px 12px; cursor:pointer; }
    .stats { color:var(--muted); }
    .card { background:var(--card); border:1px solid #1e2630; border-radius:12px; padding:14px; }
    .flex { display:flex; gap:8px; align-items:center; }
    .grid { display:grid; gap:8px; }
    .list { display:grid; grid-template-columns: 1fr auto auto; gap:6px 8px; align-items:center; }
    .list .head { color:var(--muted); font-weight:600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color:var(--muted); }
    .readme { max-height:280px; overflow:auto; background:#0e141b; border:1px solid #26303c; border-radius:8px; padding:12px; white-space:pre-wrap; }
    a { color:#9cc4ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .gallery { display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:10px; }
    .gallery img, .gallery video { width:100%; height:140px; object-fit:cover; border-radius:10px; border:1px solid #1e2630; background:#0e141b; }
    footer { padding:20px; color:var(--muted); font-size:12px; }
    .license { font-size:12px; color:var(--muted); }
    .meta-chip { background:#0e141b; border:1px solid #26303c; border-radius:8px; padding:10px 12px; }
    .meta-chip .title { font-weight:600; margin-bottom:6px; }
    .meta-chip .excerpt { white-space:pre-wrap; max-height:160px; overflow:auto; }
  </style>
</head>
<body>
  <header>
    <h1>Repo-Browser</h1>
    <div class="path" id="currentPath">/</div>
    <div class="controls">
      <input id="tokenInput" type="text" placeholder="Optional: GitHub Token (?token=... im URL auch m√∂glich)" />
      <button id="reloadBtn">Neu laden</button>
    </div>
    <div class="stats" id="stats"></div>
  </header>

  <main>
    <!-- Stand der Indizierung -->
    <section class="card grid" id="idxStatusCard">
      <div class="flex" style="justify-content:space-between;">
        <strong>Stand der Indizierung</strong>
        <span class="muted">Automatisch aus <code>manifest.json</code></span>
      </div>
      <div class="flex" style="gap:16px; flex-wrap:wrap;">
        <div><span class="muted">Letzte Aktualisierung:</span> <span id="manifestUpdatedAt" class="mono">‚Äì</span></div>
        <div><span class="muted">Gesamtdateien:</span> <span id="manifestTotalFiles" class="mono">‚Äì</span></div>
      </div>
    </section>

    <!-- README-Block -->
    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>README</strong>
        <span class="muted">wird automatisch geladen, falls vorhanden</span>
      </div>
      <div id="readme" class="readme mono">‚Äî</div>
    </section>

    <!-- Dateien & Ordner -->
    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>Dateien & Ordner</strong>
        <span id="cwdLabel" class="muted mono">/</span>
      </div>

      <!-- Meta-Block (README/Lizenz-Auszug) -->
      <div id="folderMeta" class="grid"></div>

      <div class="list" id="listing">
        <div class="head">Pfad/Name</div>
        <div class="head">Typ</div>
        <div class="head">Gr√∂√üe</div>
      </div>
    </section>

    <!-- Galerie -->
    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>Galerie</strong>
        <span class="muted">Zeigt Medien aus dem aktuellen Ordner (ohne <code>background.*</code>)</span>
      </div>
      <div class="gallery" id="gallery"></div>
    </section>

    <!-- Lizenzhinweis -->
    <section class="card license">
      <div><strong>Lizenz</strong></div>
      <div>Code: MIT License. Nicht-Code (z. B. PDFs, CSV/PNG): CC BY 4.0. ¬© 2025 antaris ‚Äî Code: MIT; Daten/Abbildungen/Texte (inkl. PDFs): CC BY 4.0.</div>
    </section>
  </main>

  <footer>
    <div>Dieses Frontend l√§dt bevorzugt <code>manifest.json</code> (falls vorhanden). Fallback: GitHub Contents API.</div>
  </footer>

  <script>
    // ====== Basiskonfiguration ======
    const OWNER = "antaris82";
    const REPO  = "antaris82.github.io";
    const BRANCH = "main";

    // Current "virtueller" Pfad im Repo (f√ºr Unterordnernavigation)
    let cwd = decodeURIComponent((new URLSearchParams(location.search)).get("path") || "");
    if (cwd.startsWith("/")) cwd = cwd.slice(1);
    if (cwd.endsWith("/"))  cwd = cwd.slice(0, -1);

    // Token-Verwendung: Query-Param > Eingabefeld
    const urlToken = (new URLSearchParams(location.search)).get("token") || "";
    const tokenInput = document.getElementById("tokenInput");
    if (urlToken) tokenInput.value = urlToken;

    const statsEl = document.getElementById("stats");
    const listingEl = document.getElementById("listing");
    const readmeEl = document.getElementById("readme");
    const galleryEl = document.getElementById("gallery");
    const cwdLabelEl = document.getElementById("cwdLabel");
    const currentPathEl = document.getElementById("currentPath");

    cwdLabelEl.textContent = "/" + (cwd || "");
    currentPathEl.textContent = "/" + (cwd || "");

    // Hilfsfunktionen
    const isMedia = (p) => /\.(png|jpg|jpeg|gif|webp|svg|mp4|webm|ogg)$/i.test(p);
    const isBackground = (name) => /^background\.(png|jpg|jpeg|gif|webp|svg)$/i.test(name);

    function humanBytes(n) {
      const units = ["B","KB","MB","GB","TB"];
      let i = 0, v = Number(n)||0;
      while (v >= 1024 && i < units.length-1) { v /= 1024; i++; }
      return (Math.round(v*10)/10) + " " + units[i];
    }

    function authHeaders() {
      const t = tokenInput.value.trim();
      return t ? { "Authorization": "Bearer " + t } : {};
    }

    function navigateTo(path) {
      const params = new URLSearchParams(location.search);
      if (urlToken && !params.get("token")) params.set("token", urlToken);
      params.set("path", path);
      location.search = params.toString();
    }

    // Manifest-Header (Last-Modified) holen
    async function getManifestHeaders() {
      try {
        const res = await fetch("/manifest.json", { method:"GET", cache:"no-store" });
        if (!res.ok) return null;
        return {
          lastModified: res.headers.get("last-modified") || null,
          contentLength: res.headers.get("content-length") || null
        };
      } catch {
        return null;
      }
    }

    // Dateiname im aktuellen Ordner finden
    function findFileInFolder(manifest, folderPath, names) {
      const prefix = folderPath ? (folderPath + "/") : "";
      // exakte Treffer im Ordner (nicht rekursiv)
      const candidates = manifest
        .filter(x => x.path.startsWith(prefix))
        .map(x => ({ ...x, rest: x.path.slice(prefix.length) }))
        .filter(x => x.rest.length > 0 && !x.rest.includes("/")); // direkte Kinder

      for (const n of names) {
        const hit = candidates.find(x => x.rest.toLowerCase() === n.toLowerCase());
        if (hit) return hit;
      }
      return null;
    }

    // Rohtext einer Repo-Datei holen (Raw)
    async function fetchRawText(path) {
      const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${path}`;
      const r = await fetch(rawUrl, { headers: { ...authHeaders() }, cache: "no-store" });
      if (!r.ok) throw new Error("Raw fetch failed " + r.status);
      return await r.text();
    }

    // Exzerpt (sauber) bauen
    function buildExcerpt(txt, maxLen=400) {
      const clean = txt.replace(/\r/g,"").trim();
      if (clean.length <= maxLen) return clean;
      return clean.slice(0, maxLen).trim() + " ‚Ä¶";
    }

    // ====== 1) Erst manifest.json versuchen ======
    async function fetchManifest() {
      try {
        const res = await fetch("/manifest.json", { cache: "no-store" });
        if (!res.ok) return null;
        return await res.json();
      } catch {
        return null;
      }
    }

    // ====== 2) Fallback: GitHub Contents API ======
    // Hole rekursiv alle Dateien (zur Not). Achtung: kann bei gro√üen Repos viele Calls nutzen; Token empfohlen.
    async function fetchAllViaAPI() {
      async function listDir(path = "") {
        const api = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(BRANCH)}`;
        const res = await fetch(api, { headers: { ...authHeaders() } });
        if (!res.ok) throw new Error("API error " + res.status);
        return await res.json(); // Array (files/dirs)
      }
      const acc = [];
      async function walk(path="") {
        const items = await listDir(path);
        for (const it of items) {
          if (it.type === "file") {
            acc.push({ path: it.path, size: it.size ?? 0, sha: it.sha, type: "blob", mode: "100644" });
          } else if (it.type === "dir") {
            await walk(it.path);
          }
        }
      }
      await walk("");
      return acc.sort((a,b)=> a.path.localeCompare(b.path));
    }

    // ====== README laden (falls vorhanden) ======
    async function loadReadme(manifest) {
      const prefix = cwd ? (cwd + "/") : "";
      const candidates = ["README.md","readme.md","README","Readme.md","README.txt","readme.txt"];
      let readmeEntry = manifest.find(x => x.path.toLowerCase() === (prefix + "readme.md")) ||
                        manifest.find(x => x.path.toLowerCase() === (prefix + "readme"));
      if (!readmeEntry) {
        for (const name of candidates) {
          const hit = manifest.find(x => x.path === (prefix + name));
          if (hit) { readmeEntry = hit; break; }
        }
      }
      if (!readmeEntry) {
        readmeEl.textContent = "Kein README im aktuellen Ordner gefunden.";
        return;
      }
      try {
        const raw = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${readmeEntry.path}`;
        const r = await fetch(raw, { headers: { ...authHeaders() }, cache: "no-store" });
        if (!r.ok) throw new Error("READMERaw error " + r.status);
        let txt = await r.text();
        readmeEl.textContent = txt;
      } catch (e) {
        readmeEl.textContent = "README konnte nicht geladen werden: " + e.message;
      }
    }

    // ====== Listing + Galerie f√ºr aktuellen Ordner ======
    function renderFolder(manifest) {
      const prefix = cwd ? (cwd + "/") : "";
      const direct = manifest
        .filter(x => x.path.startsWith(prefix))
        .map(x => ({ ...x, rest: x.path.slice(prefix.length) }))
        .filter(x => x.rest.length > 0 && !x.rest.includes("/")); // nur direkte Kinder

      const dirsSet = new Set(
        manifest
          .filter(x => x.path.startsWith(prefix))
          .map(x => x.path.slice(prefix.length))
          .filter(x => x.includes("/"))
          .map(x => x.split("/")[0])
      );
      const dirs = Array.from(dirsSet).sort();

      // UI leeren (bis auf Kopfzeile)
      listingEl.innerHTML = `
        <div class="head">Pfad/Name</div>
        <div class="head">Typ</div>
        <div class="head">Gr√∂√üe</div>
      `;

      // Meta-Block (README + LICENSE) direkt √ºber der Liste
      const folderMetaEl = document.getElementById("folderMeta");
      folderMetaEl.innerHTML = ""; // leeren

      (async () => {
        const prefixPath = cwd || ""; // aktueller Ordner
        const readmeNames  = ["README.md","readme.md","README","Readme.md","README.txt","readme.txt"];
        const licenseNames = ["LICENSE","LICENSE.md","LICENSE.txt","License","COPYING","COPYING.txt"];

        // README suchen
        const readmeEntry = findFileInFolder(manifest, prefixPath, readmeNames);
        if (readmeEntry) {
          try {
            const readmeTxt = await fetchRawText(readmeEntry.path);
            const readmeEx  = buildExcerpt(readmeTxt, 600);
            const readmeUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${readmeEntry.path}`;
            const chip = document.createElement("div");
            chip.className = "meta-chip";
            chip.innerHTML = `
              <div class="title">README <a href="${readmeUrl}" target="_blank" rel="noopener" class="mono">(${readmeEntry.rest || readmeEntry.path})</a></div>
              <div class="excerpt mono">${readmeEx.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>
            `;
            folderMetaEl.appendChild(chip);
          } catch (e) {
            const chip = document.createElement("div");
            chip.className = "meta-chip";
            chip.innerHTML = `<div class="title">README</div><div class="excerpt">Konnte nicht geladen werden: ${e.message}</div>`;
            folderMetaEl.appendChild(chip);
          }
        }

        // LICENSE suchen
        const licEntry = findFileInFolder(manifest, prefixPath, licenseNames);
        if (licEntry) {
          try {
            const licTxt = await fetchRawText(licEntry.path);
            const licEx  = buildExcerpt(licTxt, 400);
            const licUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${licEntry.path}`;
            const chip = document.createElement("div");
            chip.className = "meta-chip";
            chip.innerHTML = `
              <div class="title">Lizenz <a href="${licUrl}" target="_blank" rel="noopener" class="mono">(${licEntry.rest || licEntry.path})</a></div>
              <div class="excerpt mono">${licEx.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>
            `;
            folderMetaEl.appendChild(chip);
          } catch (e) {
            const chip = document.createElement("div");
            chip.className = "meta-chip";
            chip.innerHTML = `<div class="title">Lizenz</div><div class="excerpt">Konnte nicht geladen werden: ${e.message}</div>`;
            folderMetaEl.appendChild(chip);
          }
        }

        if (!readmeEntry && !licEntry) {
          folderMetaEl.innerHTML = `<div class="muted">Kein README/Lizenz im aktuellen Ordner gefunden.</div>`;
        }
      })();

      // "nach oben" Link, falls in Unterordner
      if (cwd) {
        const up = cwd.split("/").slice(0, -1).join("/");
        const row = document.createElement("div");
        row.className = "mono";
        row.style.gridColumn = "1 / span 3";
        row.innerHTML = `<a href="javascript:void(0)" onclick="(${navigateTo.toString()})('${up}')">‚¨ÖÔ∏é .. (nach oben)</a>`;
        listingEl.appendChild(row);
      }

      // Ordner rendern
      for (const d of dirs) {
        const rowName = document.createElement("div");
        rowName.className = "mono";
        rowName.innerHTML = `<a href="javascript:void(0)" onclick="(${navigateTo.toString()})('${cwd ? (cwd + '/') : ''}${d}')">üìÅ ${d}</a>`;
        const rowType = document.createElement("div");
        rowType.textContent = "dir";
        rowType.className = "muted mono";
        const rowSize = document.createElement("div");
        rowSize.textContent = "‚Äî";
        rowSize.className = "muted mono";
        listingEl.appendChild(rowName);
        listingEl.appendChild(rowType);
        listingEl.appendChild(rowSize);
      }

      // Dateien rendern
      for (const f of direct.filter(x => x.type === "blob")) {
        const name = f.rest;
        const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${encodeURIComponent(cwd ? (cwd + "/" + name) : name)}`;
        const rowName = document.createElement("div");
        rowName.className = "mono";
        rowName.innerHTML = `üìÑ <a href="${rawUrl}" target="_blank" rel="noopener">${name}</a>`;
        const rowType = document.createElement("div");
        rowType.textContent = "file";
        rowType.className = "muted mono";
        const rowSize = document.createElement("div");
        rowSize.textContent = humanBytes(f.size);
        rowSize.className = "muted mono";
        listingEl.appendChild(rowName);
        listingEl.appendChild(rowType);
        listingEl.appendChild(rowSize);
      }

      // Galerie rendern (nur Medien im aktuellen Ordner), background.* ausschlie√üen
      galleryEl.innerHTML = "";
      const mediaFiles = direct
        .filter(x => x.type === "blob" && isMedia(x.rest) && !isBackground(x.rest));
      for (const m of mediaFiles) {
        const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${encodeURIComponent(cwd ? (cwd + "/" + m.rest) : m.rest)}`;
        if (/\.(mp4|webm|ogg)$/i.test(m.rest)) {
          const v = document.createElement("video");
          v.src = rawUrl;
          v.controls = true;
          galleryEl.appendChild(v);
        } else {
          const img = document.createElement("img");
          img.src = rawUrl;
          img.alt = m.rest;
          galleryEl.appendChild(img);
        }
      }

      // Stats
      const totalFiles = manifest.filter(x => x.type === "blob").length;
      statsEl.textContent = `Gesamtdateien: ${totalFiles} | Aktueller Ordner: ${dirs.length} Ordner, ${direct.filter(x=>x.type==='blob').length} Dateien`;
    }

    // ====== Bootstrapping ======
    async function boot() {
      document.getElementById("reloadBtn").addEventListener("click", () => location.reload());

      let manifest = await fetchManifest();
      if (!manifest) {
        // Fallback: vollst√§ndiges Manifest via API (Token empfohlen)
        try {
          manifest = await fetchAllViaAPI();
        } catch (e) {
          statsEl.textContent = "Fehler beim Laden (API): " + e.message;
          return;
        }
      }

      // Statuskarte: Timestamp + Anzahl
      try {
        const hdr = await getManifestHeaders();
        if (hdr && hdr.lastModified) {
          const dt = new Date(hdr.lastModified);
          document.getElementById("manifestUpdatedAt").textContent = dt.toLocaleString();
        } else {
          document.getElementById("manifestUpdatedAt").textContent = "‚Äì";
        }
      } catch { /* ignore */ }

      const totalFiles = manifest.filter(x => x.type === "blob").length;
      document.getElementById("manifestTotalFiles").textContent = String(totalFiles);

      await loadReadme(manifest);
      renderFolder(manifest);
    }

    boot();
  </script>
</body>
</html>
