<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>antaris82 ‚Äî GitHub Pages Browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9aa4b2; --card:#10161d; --accent:#2f81f7; }

    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font:14px/1.45 system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,sans-serif; }
    /* Hintergrundbild (falls vorhanden) wird per JS gesetzt */
    body.bg-on {
      background-attachment: fixed;
      background-size: cover;
      background-position: center center;
    }
    /* dezente Abdunklung f√ºr Lesbarkeit */
    body.bg-on::before {
      content:"";
      position:fixed; inset:0;
      background:rgba(11,15,20,.55);
      pointer-events:none;
      z-index:-1;
    }

    .wrap { max-width: 1080px; margin: 0 auto; padding: 0 16px; }

    header { border-bottom:1px solid #1e2630; }
    header .row { padding:16px 0; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    header h1 { font-size:18px; margin:0; }
    header .path { color:var(--muted); font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }

    main.wrap { padding:16px 0 24px; display:grid; grid-template-columns: 1fr; gap:16px; }

    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .controls input[type="text"] { background:#0e141b; color:var(--fg); border:1px solid #26303c; border-radius:8px; padding:8px 10px; min-width:280px; }
    .controls button { background:var(--accent); color:white; border:0; border-radius:8px; padding:8px 12px; cursor:pointer; }
    .stats { color:var(--muted); margin-left:auto; }

    .card { background:var(--card); border:1px solid #1e2630; border-radius:12px; padding:14px; }
    .flex { display:flex; gap:8px; align-items:center; }
    .grid { display:grid; gap:8px; }
    .list { display:grid; grid-template-columns: 1fr auto auto; gap:6px 8px; align-items:center; }
    .list .head { color:var(--muted); font-weight:600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color:var(--muted); }
    .readme { max-height:420px; overflow:auto; background:#0e141b; border:1px solid #26303c; border-radius:8px; padding:16px; }
    .readme h1,.readme h2,.readme h3 { margin: 0.6em 0 0.4em; }
    .readme code { background:#0b1016; padding:0 .25em; border-radius:4px; }
    .readme pre { background:#0b1016; padding:10px; border-radius:8px; overflow:auto; }
    .readme table { border-collapse:collapse; border:1px solid #26303c; }
    .readme th,.readme td { border:1px solid #26303c; padding:6px 8px; }

    a { color:#9cc4ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .gallery { display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:10px; }
    .gallery img, .gallery video { width:100%; height:140px; object-fit:cover; border-radius:10px; border:1px solid #1e2630; background:#0e141b; }
    footer { padding:20px 0; color:var(--muted); font-size:12px; }
    .license { font-size:12px; color:var(--muted); }

    .meta-chip { background:#0e141b; border:1px solid #26303c; border-radius:8px; padding:10px 12px; }
    .meta-chip .title { font-weight:600; margin-bottom:6px; }
    .meta-chip .excerpt { white-space:pre-wrap; max-height:160px; overflow:auto; }
  </style>

  <!-- Markdown (marked) & Sanitizer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

  <!-- MathJax v3: LaTeX (\(...\), \[...\]; $$...$$ als Fallback) -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)']],
        displayMath: [['\\[','\\]'], ['$$','$$']],
        processEscapes: true,
        tags: 'ams'
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <h1>Repo-Browser</h1>
        <div class="path" id="currentPath">/</div>
        <div class="controls">
          <input id="tokenInput" type="text" placeholder="Optional: GitHub Token (?token=... im URL auch m√∂glich)" />
          <button id="reloadBtn">Neu laden</button>
        </div>
        <div class="stats" id="stats"></div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- Stand der Indizierung -->
    <section class="card grid" id="idxStatusCard">
      <div class="flex" style="justify-content:space-between;">
        <strong>Stand der Indizierung</strong>
        <span class="muted">Automatisch aus <code>manifest.json</code></span>
      </div>
      <div class="flex" style="gap:16px; flex-wrap:wrap;">
        <div><span class="muted">Letzte Aktualisierung:</span> <span id="manifestUpdatedAt" class="mono">‚Äì</span></div>
        <div><span class="muted">Gesamtdateien:</span> <span id="manifestTotalFiles" class="mono">‚Äì</span></div>
      </div>
    </section>

    <!-- README-Block -->
    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>README</strong>
        <span class="muted">wird automatisch geladen, gerendert (Markdown + LaTeX)</span>
      </div>
      <div id="readme" class="readme">‚Äî</div>
    </section>

    <!-- Dateien & Ordner -->
    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>Dateien & Ordner</strong>
        <span id="cwdLabel" class="muted mono">/</span>
      </div>

      <!-- Meta-Block (README/Lizenz-Auszug) -->
      <div id="folderMeta" class="grid"></div>

      <div class="list" id="listing">
        <div class="head">Pfad/Name</div>
        <div class="head">Typ</div>
        <div class="head">Gr√∂√üe</div>
      </div>
    </section>

    <!-- Galerie -->
    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>Galerie</strong>
        <span class="muted">Zeigt Medien aus dem aktuellen Ordner (ohne <code>background.*</code>)</span>
      </div>
      <div class="gallery" id="gallery"></div>
    </section>

    <!-- Lizenzhinweis -->
    <section class="card license">
      <div><strong>Lizenz</strong></div>
      <div>Code: MIT License. Nicht-Code (z. B. PDFs, CSV/PNG): CC BY 4.0. ¬© 2025 antaris ‚Äî Code: MIT; Daten/Abbildungen/Texte (inkl. PDFs): CC BY 4.0.</div>
    </section>
  </main>

  <footer>
    <div class="wrap">Dieses Frontend l√§dt bevorzugt <code>manifest.json</code> (falls vorhanden). Fallback: GitHub Contents API.</div>
  </footer>

  <script>
    // ====== Basiskonfiguration ======
    const OWNER = "antaris82";
    const REPO  = "antaris82.github.io";
    const BRANCH = "main";

    // Aktueller Ordner via Query
    let cwd = decodeURIComponent((new URLSearchParams(location.search)).get("path") || "");
    if (cwd.startsWith("/")) cwd = cwd.slice(1);
    if (cwd.endsWith("/"))  cwd = cwd.slice(0, -1);

    // Token: Query-Param -> Feld
    const urlToken = (new URLSearchParams(location.search)).get("token") || "";
    const tokenInput = document.getElementById("tokenInput");
    if (urlToken) tokenInput.value = urlToken;

    const statsEl = document.getElementById("stats");
    const listingEl = document.getElementById("listing");
    const readmeEl = document.getElementById("readme");
    const galleryEl = document.getElementById("gallery");
    const cwdLabelEl = document.getElementById("cwdLabel");
    const currentPathEl = document.getElementById("currentPath");

    cwdLabelEl.textContent = "/" + (cwd || "");
    currentPathEl.textContent = "/" + (cwd || "");

    // Helpers
    const isMedia = (p) => /\.(png|jpg|jpeg|gif|webp|svg|mp4|webm|ogg)$/i.test(p);
    const isBackground = (name) => /^background\.(png|jpg|jpeg|gif|webp|svg)$/i.test(name);

    function humanBytes(n) {
      const units = ["B","KB","MB","GB","TB"];
      let i = 0, v = Number(n)||0;
      while (v >= 1024 && i < units.length-1) { v /= 1024; i++;
      }
      return (Math.round(v*10)/10) + " " + units[i];
    }

    function authHeaders() {
      const t = tokenInput.value.trim();
      return t ? { "Authorization": "Bearer " + t } : {};
    }

    function getTokenParam() {
      const t = tokenInput.value.trim() || urlToken;
      return t ? `&token=${encodeURIComponent(t)}` : "";
    }

    function buildNavHref(path) {
      const base = `${location.pathname}?path=${encodeURIComponent(path)}`;
      return base + getTokenParam();
    }

    // Manifest-Header (Last-Modified) holen
    async function getManifestHeaders() {
      try {
        const res = await fetch("/manifest.json", { method:"GET", cache:"no-store" });
        if (!res.ok) return null;
        return {
          lastModified: res.headers.get("last-modified") || null,
          contentLength: res.headers.get("content-length") || null
        };
      } catch { return null; }
    }

    // Datei im aktuellen Ordner finden
    function findFileInFolder(manifest, folderPath, names) {
      const prefix = folderPath ? (folderPath + "/") : "";
      const candidates = manifest
        .filter(x => x.path.startsWith(prefix))
        .map(x => ({ ...x, rest: x.path.slice(prefix.length) }))
        .filter(x => x.rest.length > 0 && !x.rest.includes("/"));
      for (const n of names) {
        const hit = candidates.find(x => x.rest.toLowerCase() === n.toLowerCase());
        if (hit) return hit;
      }
      return null;
    }

    // Rohtext holen
    async function fetchRawText(path) {
      const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${path}`;
      const r = await fetch(rawUrl, { headers: { ...authHeaders() }, cache: "no-store" });
      if (!r.ok) throw new Error("Raw fetch failed " + r.status);
      return await r.text();
    }

    // Exzerpt
    function buildExcerpt(txt, maxLen=400) {
      const clean = txt.replace(/\r/g,"").trim();
      if (clean.length <= maxLen) return clean;
      return clean.slice(0, maxLen).trim() + " ‚Ä¶";
    }

    // ====== 1) Erst manifest.json versuchen ======
    async function fetchManifest() {
      try {
        const res = await fetch("/manifest.json", { cache: "no-store" });
        if (!res.ok) return null;
        return await res.json();
      } catch { return null; }
    }

    // ====== 2) Fallback: GitHub Contents API (rekursiv) ======
    async function fetchAllViaAPI() {
      async function listDir(path = "") {
        const api = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(BRANCH)}`;
        const res = await fetch(api, { headers: { ...authHeaders() } });
        if (!res.ok) throw new Error("API error " + res.status);
        return await res.json();
      }
      const acc = [];
      async function walk(path="") {
        const items = await listDir(path);
        for (const it of items) {
          if (it.type === "file") {
            acc.push({ path: it.path, size: it.size ?? 0, sha: it.sha, type: "blob", mode: "100644" });
          } else if (it.type === "dir") {
            await walk(it.path);
          }
        }
      }
      await walk("");
      return acc.sort((a,b)=> a.path.localeCompare(b.path));
    }

    // MathJax Typeset Helper
    function typeset(el) {
      return new Promise((resolve) => {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise([el]).then(() => resolve()).catch(() => resolve());
        } else {
          // Falls MathJax noch nicht geladen ist, sp√§ter nochmal versuchen
          let tries = 0;
          const t = setInterval(() => {
            if (window.MathJax && MathJax.typesetPromise) {
              clearInterval(t);
              MathJax.typesetPromise([el]).then(() => resolve()).catch(() => resolve());
            } else if (++tries > 40) { // ~8s
              clearInterval(t); resolve();
            }
          }, 200);
        }
      });
    }

    // README laden + Markdown + LaTeX rendern
    async function loadReadme(manifest) {
      const prefix = cwd ? (cwd + "/") : "";
      const candidates = ["README.md","readme.md","README","Readme.md","README.txt","readme.txt"];
      let readmeEntry = manifest.find(x => x.path.toLowerCase() === (prefix + "readme.md")) ||
                        manifest.find(x => x.path.toLowerCase() === (prefix + "readme"));
      if (!readmeEntry) {
        for (const name of candidates) {
          const hit = manifest.find(x => x.path === (prefix + name));
          if (hit) { readmeEntry = hit; break; }
        }
      }
      if (!readmeEntry) {
        readmeEl.textContent = "Kein README im aktuellen Ordner gefunden.";
        return;
      }
      try {
        const raw = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${readmeEntry.path}`;
        const r = await fetch(raw, { headers: { ...authHeaders() }, cache: "no-store" });
        if (!r.ok) throw new Error("READMERaw error " + r.status);
        const txt = await r.text();

        // Markdown -> HTML, danach sicher sanitisieren
        const html = DOMPurify.sanitize(marked.parse(txt, { mangle: false, headerIds: true }));
        readmeEl.innerHTML = html;

        // LaTeX (MathJax) auf README anwenden
        await typeset(readmeEl);
      } catch (e) {
        readmeEl.textContent = "README konnte nicht geladen/gerendert werden: " + e.message;
      }
    }

    // Hintergrund automatisch setzen, wenn im Root background.* existiert
    function applyBackgroundFromManifest(manifest) {
      const bg = manifest.find(x => !x.path.includes("/") && /^background\.(png|jpg|jpeg|gif|webp|svg)$/i.test(x.path));
      if (!bg) return;
      const url = `/${bg.path}`; // GH Pages Root
      document.body.style.backgroundImage = `linear-gradient(rgba(11,15,20,0.6), rgba(11,15,20,0.6)), url('${url}')`;
      document.body.classList.add("bg-on");
    }

    // Ordner-Listing + Galerie
    function renderFolder(manifest) {
      const prefix = cwd ? (cwd + "/") : "";
      const direct = manifest
        .filter(x => x.path.startsWith(prefix))
        .map(x => ({ ...x, rest: x.path.slice(prefix.length) }))
        .filter(x => x.rest.length > 0 && !x.rest.includes("/"));

      const dirsSet = new Set(
        manifest
          .filter(x => x.path.startsWith(prefix))
          .map(x => x.path.slice(prefix.length))
          .filter(x => x.includes("/"))
          .map(x => x.split("/")[0])
      );
      const dirs = Array.from(dirsSet).sort();

      // Kopf der Tabelle
      listingEl.innerHTML = `
        <div class="head">Pfad/Name</div>
        <div class="head">Typ</div>
        <div class="head">Gr√∂√üe</div>
      `;

      // Meta-Block (README + LICENSE)
      const folderMetaEl = document.getElementById("folderMeta");
      folderMetaEl.innerHTML = "";
      (async () => {
        const prefixPath = cwd || "";
        const readmeNames  = ["README.md","readme.md","README","Readme.md","README.txt","readme.txt"];
        const licenseNames = ["LICENSE","LICENSE.md","LICENSE.txt","License","COPYING","COPYING.txt"];

        const readmeEntry = findFileInFolder(manifest, prefixPath, readmeNames);
        if (readmeEntry) {
          try {
            const readmeTxt = await fetchRawText(readmeEntry.path);
            const readmeEx  = buildExcerpt(readmeTxt, 600);
            const readmeUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${readmeEntry.path}`;
            const chip = document.createElement("div");
            chip.className = "meta-chip";
            chip.innerHTML = `
              <div class="title">README <a href="${readmeUrl}" target="_blank" rel="noopener" class="mono">(${readmeEntry.rest || readmeEntry.path})</a></div>
              <div class="excerpt mono">${readmeEx.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>
            `;
            folderMetaEl.appendChild(chip);
          } catch (e) {
            const chip = document.createElement("div"); chip.className = "meta-chip";
            chip.innerHTML = `<div class="title">README</div><div class="excerpt">Konnte nicht geladen werden: ${e.message}</div>`;
            folderMetaEl.appendChild(chip);
          }
        }

        const licEntry = findFileInFolder(manifest, prefixPath, licenseNames);
        if (licEntry) {
          try {
            const licTxt = await fetchRawText(licEntry.path);
            const licEx  = buildExcerpt(licTxt, 400);
            const licUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${licEntry.path}`;
            const chip = document.createElement("div");
            chip.className = "meta-chip";
            chip.innerHTML = `
              <div class="title">Lizenz <a href="${licUrl}" target="_blank" rel="noopener" class="mono">(${licEntry.rest || licEntry.path})</a></div>
              <div class="excerpt mono">${licEx.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>
            `;
            folderMetaEl.appendChild(chip);
          } catch (e) {
            const chip = document.createElement("div"); chip.className = "meta-chip";
            chip.innerHTML = `<div class="title">Lizenz</div><div class="excerpt">Konnte nicht geladen werden: ${e.message}</div>`;
            folderMetaEl.appendChild(chip);
          }
        }

        if (!readmeEntry && !licEntry) {
          folderMetaEl.innerHTML = `<div class="muted">Kein README/Lizenz im aktuellen Ordner gefunden.</div>`;
        }
      })();

      // Nach oben Link (per normalem href)
      if (cwd) {
        const up = cwd.split("/").slice(0, -1).join("/");
        const row = document.createElement("div");
        row.className = "mono";
        row.style.gridColumn = "1 / span 3";
        row.innerHTML = `<a href="${buildNavHref(up)}">‚¨ÖÔ∏é .. (nach oben)</a>`;
        listingEl.appendChild(row);
      }

      // Ordner rendern (normale Links)
      for (const d of dirs) {
        const rowName = document.createElement("div");
        rowName.className = "mono";
        rowName.innerHTML = `<a href="${buildNavHref(cwd ? (cwd + '/' + d) : d)}">üìÅ ${d}</a>`;
        const rowType = document.createElement("div");
        rowType.textContent = "dir";
        rowType.className = "muted mono";
        const rowSize = document.createElement("div");
        rowSize.textContent = "‚Äî";
        rowSize.className = "muted mono";
        listingEl.appendChild(rowName);
        listingEl.appendChild(rowType);
        listingEl.appendChild(rowSize);
      }

      // Dateien rendern
      for (const f of direct.filter(x => x.type === "blob")) {
        const name = f.rest;
        const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${encodeURIComponent(cwd ? (cwd + "/" + name) : name)}`;
        const rowName = document.createElement("div");
        rowName.className = "mono";
        rowName.innerHTML = `üìÑ <a href="${rawUrl}" target="_blank" rel="noopener">${name}</a>`;
        const rowType = document.createElement("div");
        rowType.textContent = "file";
        const rowSize = document.createElement("div");
        rowType.className = "muted mono";
        rowSize.textContent = humanBytes(f.size);
        rowSize.className = "muted mono";
        listingEl.appendChild(rowName);
        listingEl.appendChild(rowType);
        listingEl.appendChild(rowSize);
      }

      // Galerie (ohne background.*)
      galleryEl.innerHTML = "";
      const mediaFiles = direct.filter(x => x.type === "blob" && isMedia(x.rest) && !isBackground(x.rest));
      for (const m of mediaFiles) {
        const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${encodeURIComponent(cwd ? (cwd + "/" + m.rest) : m.rest)}`;
        if (/\.(mp4|webm|ogg)$/i.test(m.rest)) {
          const v = document.createElement("video");
          v.src = rawUrl; v.controls = true; galleryEl.appendChild(v);
        } else {
          const img = document.createElement("img");
          img.src = rawUrl; img.alt = m.rest; galleryEl.appendChild(img);
        }
      }

      // Stats
      const totalFiles = manifest.filter(x => x.type === "blob").length;
      statsEl.textContent = `Gesamtdateien: ${totalFiles} | Aktueller Ordner: ${dirs.length} Ordner, ${direct.filter(x=>x.type==='blob').length} Dateien`;
    }

    // ====== Bootstrapping ======
    async function boot() {
      document.getElementById("reloadBtn").addEventListener("click", () => location.reload());

      let manifest = await fetchManifest();
      if (!manifest) {
        try { manifest = await fetchAllViaAPI(); }
        catch (e) { statsEl.textContent = "Fehler beim Laden (API): " + e.message; return; }
      }

      // Hintergrund setzen (falls background.* im Root existiert)
      applyBackgroundFromManifest(manifest);

      // Statuskarte
      try {
        const hdr = await getManifestHeaders();
        if (hdr && hdr.lastModified) {
          const dt = new Date(hdr.lastModified);
          document.getElementById("manifestUpdatedAt").textContent = dt.toLocaleString();
        } else {
          document.getElementById("manifestUpdatedAt").textContent = "‚Äì";
        }
      } catch { /* ignore */ }
      const totalFiles = manifest.filter(x => x.type === "blob").length;
      document.getElementById("manifestTotalFiles").textContent = String(totalFiles);

      await loadReadme(manifest);
      renderFolder(manifest);
    }

    boot();
  </script>
</body>
</html>
