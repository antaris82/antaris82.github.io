<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Index</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #10172a;
      --muted: #9fb0d0;
      --fg: #e6edff;
      --acc: #7aa2ff;
      --acc2: #37d2a7;
      --danger: #ff6b6b;
      --card: #0f1528;
      --border: #1d2742;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 10% -10%, #1b2652 0%, transparent 46%),
                 radial-gradient(1000px 600px at 110% -10%, #17334f 0%, transparent 45%),
                 var(--bg);
      color: var(--fg); font: 15px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--acc); text-decoration: none; }
    a:hover { text-decoration: underline; }

    header {
      position: sticky; top: 0; z-index: 5; backdrop-filter: blur(8px);
      background: linear-gradient(180deg, rgba(16,23,42,0.9), rgba(16,23,42,0.6));
      border-bottom: 1px solid var(--border);
    }
    .container { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .title { display: flex; align-items: center; gap: 12px; }
    .logo {
      width: 28px; height: 28px; border-radius: 8px; background: linear-gradient(135deg, var(--acc), var(--acc2));
      display: grid; place-items: center; color: #0b1020; font-weight: 800; box-shadow: var(--shadow);
    }

    .controls { display: grid; grid-template-columns: 1fr auto auto; gap: 10px; margin-top: 12px; }
    .search { position: relative; }
    .search input {
      width: 100%; padding: 12px 14px 12px 38px; border-radius: var(--radius);
      border: 1px solid var(--border); background: var(--panel); color: var(--fg);
    }
    .search svg { position: absolute; top: 50%; left: 12px; transform: translateY(-50%); opacity: .6; }

    .pill {
      border-radius: 999px; border: 1px solid var(--border); background: var(--panel);
      color: var(--fg); padding: 10px 14px; display: inline-flex; gap: 8px; align-items: center; cursor: pointer;
    }
    .pill input { accent-color: var(--acc); }
    .btn { border-radius: 10px; padding: 10px 14px; border: 1px solid var(--border); background: var(--panel); color: var(--fg); cursor: pointer; }
    .btn:hover { border-color: #2a3a66; }

    .crumbs { margin-top: 10px; color: var(--muted); font-size: 14px; white-space: nowrap; overflow: auto; }
    .crumbs a { color: var(--fg); opacity: .9; }
    .crumbs .sep { opacity: .4; margin: 0 6px; }

    main { padding: 18px 16px 32px; }
    .panel { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); overflow: hidden; }

    table { width: 100%; border-collapse: collapse; }
    thead th { text-align: left; font-weight: 600; color: var(--muted); background: rgba(0,0,0,0.15); }
    th, td { padding: 12px 14px; border-bottom: 1px solid var(--border); }
    tbody tr:hover { background: rgba(122,162,255,0.08); }
    .namecell { display: flex; align-items: center; gap: 10px; }
    .fileicon, .foldericon { width: 22px; height: 22px; border-radius: 6px; display: grid; place-items: center; }
    .foldericon { background: rgba(122,162,255,0.18); color: var(--acc); }
    .fileicon { background: rgba(55,210,167,0.18); color: var(--acc2); }

    .empty { padding: 28px; text-align: center; color: var(--muted); }

    details.settings {
      margin-top: 14px; border: 1px dashed var(--border); border-radius: var(--radius); padding: 8px 12px; background: rgba(0,0,0,0.1);
    }
    details.settings summary { cursor: pointer; color: var(--muted); }
    .settings-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; margin-top: 10px; }
    .settings-grid label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    .settings-grid input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: var(--panel); color: var(--fg); }
    .settings-actions { display: flex; gap: 10px; margin-top: 10px; }

    footer { color: var(--muted); font-size: 13px; padding: 24px 16px 60px; text-align: center; }
    code.kv { background: rgba(255,255,255,.06); padding: 2px 6px; border-radius: 6px; }

    .tag { font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
    @media (max-width: 700px) { .controls { grid-template-columns: 1fr; } .settings-grid { grid-template-columns: 1fr; } }

    /* README panel */
    .readme { margin-top: 16px; background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); }
    .readme h3 { margin: 0; font-size: 16px; padding: 12px 14px; color: var(--muted); background: rgba(255,255,255,0.03); }
    .readme textarea {
      width: 100%; border: 0; resize: vertical; min-height: 160px; max-height: 420px;
      padding: 12px 14px; background: transparent; color: var(--fg); line-height: 1.5; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      border-top: 1px solid var(--border); overflow: auto;
    }

    /* Gallery (full width at bottom) */
    .gallery-wrap {
      width: 100vw; margin-left: calc(50% - 50vw); /* full-bleed */
      background: linear-gradient(180deg, rgba(16,23,42,0.7), rgba(16,23,42,0.9));
      border-top: 1px solid var(--border);
      padding: 14px 0 18px;
      position: relative;
    }
    .gallery-title { max-width: 1100px; margin: 0 auto 10px; padding: 0 16px; color: var(--muted); font-size: 14px; }
    .gallery { overflow: hidden; }
    .gallery-track {
      display: flex; gap: 10px; padding: 0 56px; /* space for arrows */
      scroll-behavior: smooth;
    }
    .gal-item {
      flex: 0 0 calc((100vw - 112px - 40px) / 5); /* 5 items max visible */
      max-width: 320px;
      aspect-ratio: 16/9;
      border: 1px solid var(--border); border-radius: 12px; background: #0f1528;
      display: grid; place-items: center; overflow: hidden; box-shadow: var(--shadow);
      cursor: pointer;
    }
    .gal-item img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .gal-arrow {
      position: absolute; top: 50%; transform: translateY(-50%);
      width: 42px; height: 42px; border-radius: 50%;
      background: var(--panel); border: 1px solid var(--border); color: var(--fg);
      display: grid; place-items: center; cursor: pointer; box-shadow: var(--shadow);
    }
    .gal-arrow:hover { border-color: #2a3a66; }
    .gal-arrow.left { left: 10px; }
    .gal-arrow.right { right: 10px; }
    @media (max-width: 900px) { .gal-item { flex-basis: calc((100vw - 112px - 40px) / 3); } }
    @media (max-width: 580px) { .gal-item { flex-basis: calc((100vw - 112px - 40px) / 2); } }

    /* Diagnostics (optional) */
    .diag { color: var(--muted); font-size: 12px; margin-top: 6px; }
  </style>
</head>
<body>
<header>
  <div class="container">
    <div class="title">
      <div class="logo">∑</div>
      <div>
        <div style="font-weight:700;font-size:18px">Verzeichnisindex</div>
        <div style="color:var(--muted);font-size:13px">Listet Dateien & Ordner dieses Repos (Client-Side, GitHub API)</div>
      </div>
    </div>

    <div class="controls">
      <div class="search">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 21l-4.3-4.3M10.5 18a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15Z" stroke="currentColor" stroke-width="1.6"/></svg>
        <input id="search" placeholder="Suchen… (Name, Endung)" />
      </div>
      <label class="pill"><input type="checkbox" id="toggleHidden"> Versteckte Dateien anzeigen</label>
      <button id="btnUp" class="btn" title="Eine Ebene nach oben">↑ Ebene</button>
    </div>

    <div class="crumbs" id="breadcrumbs"></div>

    <details class="settings">
      <summary>Erweitert: Repo/Branch/Prefix konfigurieren</summary>
      <div class="settings-grid">
        <div><label>Owner</label><input id="cfgOwner" placeholder="z. B. antaris"/></div>
        <div><label>Repo</label><input id="cfgRepo" placeholder="z. B. mein-repo"/></div>
        <div><label>Branch <span class="tag">auto</span></label><input id="cfgBranch" placeholder="gh-pages / main / master"/></div>
        <div><label>Prefix im Repo (z. B. <code>docs</code>)</label><input id="cfgPrefix" placeholder="optional, ohne führenden /"/></div>
        <div style="grid-column: 1 / -1"><label>GitHub Token (optional, erhöht Rate-Limit)</label><input id="cfgToken" placeholder="ghp_… (lokal gespeichert)"/></div>
      </div>
      <div class="settings-actions">
        <button class="btn" id="btnSave">Speichern</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>
      <div style="margin-top:10px;color:var(--muted);font-size:13px">Parameter auch per Query-String: <code class="kv">?p=unter/ordner&owner=NAME&repo=REPO&branch=main&prefix=docs</code></div>
    </details>
  </div>
</header>

<main class="container">
  <div class="panel">
    <table>
      <thead>
        <tr><th>Name</th><th>Größe</th><th>Typ</th></tr>
      </thead>
      <tbody id="tbody">
        <tr><td colspan="3" class="empty">Lade…</td></tr>
      </tbody>
    </table>
  </div>

  <!-- README panel (hidden by default) -->
  <section id="readmePanel" class="readme" hidden>
    <h3 id="readmeTitle">README</h3>
    <textarea id="readmeBox" readonly spellcheck="false" placeholder="README wird geladen …"></textarea>
  </section>

  <div id="error" class="empty" style="display:none;color:var(--danger)"></div>

  <div class="diag" id="diag" style="display:none"></div>
</main>

<footer>
  <div>Erstellt von <span style="opacity:.8">index.html</span>. Nutzt die GitHub REST API (<em>ohne</em> Server-Code).<br/>Unauthentifiziertes Rate-Limit: <strong>60</strong> Anfragen/Stunde/IP.</div>
</footer>

<!-- Full-width gallery at the very bottom -->
<section class="gallery-wrap" id="galleryWrap" aria-label="Bilder-Galerie">
  <div class="gallery-title">Bilder aus dem gesamten Repo (max. 5 gleichzeitig sichtbar)</div>
  <button class="gal-arrow left" id="galPrev" title="Zurück">◀</button>
  <div class="gallery">
    <div class="gallery-track" id="galleryTrack" role="list"></div>
  </div>
  <button class="gal-arrow right" id="galNext" title="Weiter">▶</button>
</section>

<script>
(function(){
  const qs = new URLSearchParams(location.search);
  const $ = sel => document.querySelector(sel);
  const tbody = $('#tbody');
  const breadcrumbsEl = $('#breadcrumbs');
  const searchInput = $('#search');
  const toggleHidden = $('#toggleHidden');
  const btnUp = $('#btnUp');

  // README elements
  const readmePanel = $('#readmePanel');
  const readmeBox = $('#readmeBox');
  const readmeTitle = $('#readmeTitle');

  // Gallery elements
  const galleryWrap = $('#galleryWrap');
  const galleryTrack = $('#galleryTrack');
  const galPrev = $('#galPrev');
  const galNext = $('#galNext');

  const diagEl = $('#diag');

  const IMG_EXT = /\.(png|jpe?g|gif|webp|svg)$/i;
  const README_RX = /^readme(?:\.[a-z0-9]+)?$/i;

  const store = {
    get(){ try { return JSON.parse(localStorage.getItem('dirindex.cfg')||'{}'); } catch { return {}; } },
    set(v){ localStorage.setItem('dirindex.cfg', JSON.stringify(v)); }
  };

  function siteBase(){
    const host = location.hostname;
    const path = location.pathname;
    if (/\.github\.io$/i.test(host)) {
      const segs = path.split('/').filter(Boolean);
      if (segs.length>0) return '/' + segs[0] + '/';
    }
    return '/';
  }

  function currentFolderInSite(){
    let p = location.pathname;
    const base = siteBase();
    if (p.startsWith(base)) p = p.slice(base.length-1); // keep leading '/'
    p = p.replace(/index\.html?$/i, '');
    const qp = qs.get('p');
    if (qp) {
      p = ('/' + qp).replace(/\/+/g,'/');
      if (!p.endsWith('/')) p += '/';
    }
    return p;
  }

  function inferOwnerRepo(cfg){
    const host = location.hostname;
    const path = location.pathname;
    if (/\.github\.io$/i.test(host)) {
      const owner = host.split('.')[0];
      const segs = path.split('/').filter(Boolean);
      const repo = segs.length>0 ? segs[0] : (owner + '.github.io');
      return { owner, repo };
    }
    return { owner: cfg.owner, repo: cfg.repo };
  }

  // --- GitHub API helpers ---
  async function ghFetch(url, token){
    const headers = {
      'Accept': 'application/vnd.github+json',
      'X-GitHub-Api-Version': '2022-11-28'
    };
    if (token) headers['Authorization'] = 'Bearer ' + token;
    const res = await fetch(url, { headers });
    if (!res.ok) {
      const text = await res.text().catch(()=>String(res.status));
      const isRate = res.status === 403 && /rate limit/i.test(text);
      const err = new Error(text || ('HTTP '+res.status));
      err.status = res.status; err.body = text; err.url = url;
      err.code = isRate ? 'RATE_LIMIT' : undefined;
      throw err;
    }
    return res.json();
  }

  async function repoDefaultBranch(owner, repo, token){
    const info = await ghFetch(`https://api.github.com/repos/${owner}/${repo}`, token);
    return info && info.default_branch ? info.default_branch : 'main';
  }

  function bytes(n){ if (n==null) return '—'; if (n<1024) return n+' B'; if (n<1024*1024) return (n/1024).toFixed(1)+' KB'; return (n/1024/1024).toFixed(2)+' MB'; }
  function esc(s){ return s.replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
  function joinUrl(...parts){ return parts.map((p,i)=> i===0? p.replace(/\/?$/,'') : p.replace(/^\/+/, '')).join('/'); }
  function encodePath(p){ return p.split('/').map(encodeURIComponent).join('/'); }

  function applySettingsToUI(cfg){
    $('#cfgOwner').value = cfg.owner||'';
    $('#cfgRepo').value = cfg.repo||'';
    $('#cfgBranch').value = cfg.branch||'';
    $('#cfgPrefix').value = cfg.prefix||'';
    $('#cfgToken').value = cfg.token||'';
  }

  function readSettings(){
    const saved = store.get();
    const cfg = {
      owner: qs.get('owner') || saved.owner || '',
      repo: qs.get('repo') || saved.repo || '',
      branch: qs.get('branch') || saved.branch || '',
      prefix: (qs.get('prefix') || saved.prefix || '').replace(/^\/+|\/+$|^\.+/g,''),
      token: qs.get('token') || saved.token || ''
    };
    applySettingsToUI(cfg);
    return cfg;
  }

  function saveSettings(){
    const cfg = {
      owner: $('#cfgOwner').value.trim(),
      repo: $('#cfgRepo').value.trim(),
      branch: $('#cfgBranch').value.trim(),
      prefix: $('#cfgPrefix').value.trim().replace(/^\/+|\/+$|^\.+/g,''),
      token: $('#cfgToken').value.trim()
    };
    store.set(cfg);
    return cfg;
  }

  function resetSettings(){ store.set({}); localStorage.removeItem(cacheKey()); location.href = location.pathname; }

  function setError(msg){
    $('#error').style.display = 'block';
    $('#error').textContent = msg;
  }

  function clearError(){ $('#error').style.display='none'; $('#error').textContent=''; }

  function buildCrumbs(path){
    const parts = path.split('/').filter(Boolean);
    const acc = [];
    let html = '<a href="#" data-path="/">/</a>';
    parts.forEach((p)=>{
      acc.push(p);
      html += '<span class="sep">›</span>' + `<a href="#" data-path="/${acc.join('/')}/">${esc(p)}</a>`;
    });
    breadcrumbsEl.innerHTML = html;
    breadcrumbsEl.querySelectorAll('a').forEach(a=>{
      a.addEventListener('click', (e)=>{ e.preventDefault(); navigateTo(a.dataset.path); });
    });
  }

  function linkFor(sitePath){
    const base = siteBase();
    let href = joinUrl(base, sitePath);
    if (!href.endsWith('/')) return href;
    return href;
  }

  function rowHtml(entry, siteRelPath){
    const isDir = entry.type === 'dir';
    const icon = isDir ? '<div class="foldericon">📁</div>' : '<div class="fileicon">📄</div>';
    const name = esc(entry.name);
    const size = isDir ? '—' : bytes(entry.size);
    const type = isDir ? 'Ordner' : (entry.name.includes('.')? entry.name.split('.').pop().toLowerCase()+'-Datei' : 'Datei');
    if (isDir) {
      return `<tr class="row dir" data-name="${esc(entry.name)}" data-path="${esc(siteRelPath)}"><td class="namecell">${icon}<a href="#" class="nav">${name}</a></td><td>${size}</td><td>${type}</td></tr>`;
    } else {
      const href = linkFor(siteRelPath);
      return `<tr class="row file" data-name="${esc(entry.name)}"><td class="namecell">${icon}<a href="${href}">${name}</a></td><td>${size}</td><td>${type}</td></tr>`;
    }
  }

  function filterAndRender(entries, path){
    const showHidden = toggleHidden.checked;
    const q = searchInput.value.toLowerCase().trim();
    const filtered = entries.filter(e=>{
      if (!showHidden && e.name.startsWith('.')) return false;
      if (!q) return true;
      return e.name.toLowerCase().includes(q);
    });

    filtered.sort((a,b)=>{
      if (a.type!==b.type) return a.type==='dir' ? -1 : 1;
      return a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'});
    });

    if (filtered.length===0) {
      tbody.innerHTML = '<tr><td colspan="3" class="empty">Nichts gefunden.</td></tr>';
      return;
    }

    const sitePath = path.startsWith('/')? path : '/' + path;
    tbody.innerHTML = filtered.map(e=>{
      const itemSiteRel = joinUrl(sitePath, e.name) + (e.type==='dir' ? '/' : '');
      return rowHtml(e, itemSiteRel);
    }).join('');

    tbody.querySelectorAll('tr.dir .nav').forEach(a=>{
      a.addEventListener('click', (ev)=>{
        ev.preventDefault();
        const tr = a.closest('tr');
        const p = tr.dataset.path;
        navigateTo(p);
      });
    });
  }

  function pushHistory(path){
    const url = new URL(location.href);
    url.searchParams.set('p', path.replace(/^\/+|\/+$|\.+/g,''));
    history.pushState({path}, '', url);
  }

  const DETECT_CACHE_PREFIX = 'dirindex.detect:'; // key = dirindex.detect:owner/repo
  function cacheKey(owner, repo){ 
    const infer = owner && repo ? {owner, repo} : inferOwnerRepo(readSettings());
    return `${DETECT_CACHE_PREFIX}${infer.owner}/${infer.repo}`;
  }

  async function detectBranchAndPrefix(owner, repo, token){
    // Cache zuerst
    try {
      const cached = JSON.parse(localStorage.getItem(cacheKey(owner,repo)) || 'null');
      if (cached && cached.branch) return cached; // {branch, prefix}
    } catch {}

    const qsBranch = qs.get('branch');
    const saved = readSettings();
    const defBranch = await repoDefaultBranch(owner, repo, token).catch(()=>null);

    const branchCandidates = Array.from(new Set(
      [qsBranch, saved.branch, 'gh-pages', defBranch, 'main', 'master'].filter(Boolean)
    ));
    const prefixCandidates = Array.from(new Set(
      [qs.get('prefix'), saved.prefix || null, '', 'docs', 'public'].filter(v => v !== undefined)
    ));

    // Wichtig: immer am Repo-ROOT prüfen (nicht am aktuellen Unterordner)
    for (const br of branchCandidates){
      for (const pref of prefixCandidates){
        const tryPath = (pref || '').replace(/^\/+|\/+$/g,'');
        const apiUrlRoot = `https://api.github.com/repos/${owner}/${repo}/contents/${encodePath(tryPath)}?ref=${encodeURIComponent(br)}`;
        try {
          const res = await ghFetch(apiUrlRoot, token);
          if (Array.isArray(res)) {
            const found = { branch: br, prefix: tryPath };
            try { localStorage.setItem(cacheKey(owner,repo), JSON.stringify(found)); } catch {}
            return found;
          }
        } catch(e){
          if (e.code === 'RATE_LIMIT') {
            throw new Error('GitHub Rate-Limit erreicht. Unter „Erweitert“ ein Token (ghp_…) eintragen oder später erneut versuchen.');
          }
          // sonst weiterversuchen
        }
      }
    }
    throw new Error('Branch/Prefix konnte nicht automatisch bestimmt werden. Bitte unter „Erweitert“ konfigurieren.');
  }

  let STATE = { owner:null, repo:null, branch:null, prefix:'', token:null, path:'/' };
  let GALLERY_BUILT = false;
  let GALLERY_ITEMS = [];

  async function load(path){
    clearError();
    tbody.innerHTML = '<tr><td colspan="3" class="empty">Lade…</td></tr>';

    const cfg = readSettings();
    const infer = inferOwnerRepo(cfg);
    const owner = infer.owner; const repo = infer.repo;
    if (!owner || !repo){
      setError('Owner/Repo unbekannt. Auf *.github.io wird automatisch erkannt; sonst unter „Erweitert“ setzen.');
      return;
    }

    let branch = cfg.branch; let prefix = cfg.prefix||''; const token = cfg.token||'';

    // Prefill aus Cache
    if (!branch) {
      try {
        const cached = JSON.parse(localStorage.getItem(cacheKey(owner,repo)) || 'null');
        if (cached) { branch = cached.branch || branch; prefix = (cached.prefix ?? prefix); }
      } catch {}
    }

    async function tryFetch(br, pref, repoSubPath){
      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodePath(joinUrl(pref, repoSubPath))}?ref=${encodeURIComponent(br)}`;
      return ghFetch(apiUrl, token);
    }

    let data = null;

    if (!branch){
      try {
        const det = await detectBranchAndPrefix(owner, repo, token);
        branch = det.branch; prefix = det.prefix;
        data = await tryFetch(branch, prefix, path);
      } catch(e){ setError(e.message); return; }
    } else {
      try { data = await tryFetch(branch, prefix, path); }
      catch(e){
        try {
          const det = await detectBranchAndPrefix(owner, repo, token);
          branch = det.branch; prefix = det.prefix; data = await tryFetch(branch, prefix, path);
        } catch(e2){ setError('Fehler beim Laden: '+(e2.body||e2.message)); return; }
      }
    }

    STATE = { owner, repo, branch, prefix, token, path };

    buildCrumbs(path);

    const entries = Array.isArray(data)? data.filter(x=> x.type==='file'||x.type==='dir') : [];
    filterAndRender(entries, path);

    // README laden (falls vorhanden)
    try { await loadReadmeIfAny(entries); } catch { /* ignore */ }

    // Galerie nur einmal pro Konfiguration aufbauen
    if (!GALLERY_BUILT) {
      try { await buildGalleryGlobal(); } catch (e) { /* optional */ }
    }

    // Diagnostics optional einblenden (Strg+D toggelt)
    renderDiag();
  }

  function navigateTo(path){
    if (!path.endsWith('/')) path += '/';
    pushHistory(path.replace(/^\/+/,''));
    load(path);
  }

  // README loader
  async function loadReadmeIfAny(entries){
    const readme = entries.find(e => e.type==='file' && README_RX.test(e.name));
    if (!readme){
      readmePanel.hidden = true;
      return;
    }
    readmePanel.hidden = false;
    readmeTitle.textContent = `README – ${readme.name}`;
    readmeBox.value = 'Lade…';
    try {
      const url = readme.download_url;
      const res = await fetch(url, { cache: 'no-store' });
      const text = await res.text();
      readmeBox.value = text;
    } catch (e) {
      readmeBox.value = 'README konnte nicht geladen werden.';
    }
  }

  // Gallery builder (global, über gesamtes Repo/Prefix)
  async function buildGalleryGlobal(){
    const { owner, repo, branch, prefix, token } = STATE;
    let treeJson;
    async function fetchTreeWith(ref){
      const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${encodeURIComponent(ref)}?recursive=1`;
      return ghFetch(url, token);
    }
    try {
      treeJson = await fetchTreeWith(branch);
    } catch {
      // Branch SHA auflösen
      const ref = await ghFetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${encodeURIComponent(branch)}`, token);
      const sha = (ref && ref.object && ref.object.sha) ? ref.object.sha : branch;
      treeJson = await fetchTreeWith(sha);
    }
    const tree = (treeJson && treeJson.tree) || [];
    const pref = prefix ? prefix.replace(/\/+$/,'') + '/' : '';

    // Bilder unter prefix* sammeln
    const imgs = tree
      .filter(n => n.type === 'blob' && IMG_EXT.test(n.path) && (!prefix || n.path.startsWith(pref)))
      .map(n => {
        const dirFull = n.path.replace(/\/[^\/]+$/,'');             // mit prefix
        const dirUnderPrefix = prefix
          ? (dirFull.startsWith(pref) ? dirFull.slice(pref.length) : dirFull)
          : dirFull;
        const raw = `https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(branch)}/${encodePath(n.path)}`;
        return { path: n.path, raw, dirFull, dirUnderPrefix };
      });

    imgs.sort((a,b)=> a.path.localeCompare(b.path, undefined, {numeric:true, sensitivity:'base'}));

    GALLERY_ITEMS = imgs;
    renderGallery();
    GALLERY_BUILT = true;
  }

  function renderGallery(){
    galleryTrack.innerHTML = '';
    if (!GALLERY_ITEMS.length){
      galleryWrap.style.display = 'none';
      return;
    }
    galleryWrap.style.display = '';

    const frag = document.createDocumentFragment();
    GALLERY_ITEMS.forEach((it)=>{
      const item = document.createElement('div');
      item.className = 'gal-item';
      item.setAttribute('role','listitem');
      item.dataset.dir = '/' + it.dirUnderPrefix.replace(/^\/+/,'') + '/';
      item.title = it.path;
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.alt = it.path;
      img.src = it.raw;
      item.appendChild(img);
      item.addEventListener('click', ()=>{
        navigateTo(item.dataset.dir);
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
      frag.appendChild(item);
    });
    galleryTrack.appendChild(frag);

    // Scroll um eine Kartenbreite
    function oneItemWidth(){
      const first = galleryTrack.querySelector('.gal-item');
      return first ? (first.getBoundingClientRect().width + 10) : 200;
    }
    galPrev.onclick = ()=> galleryTrack.scrollBy({ left: -oneItemWidth(), behavior: 'smooth' });
    galNext.onclick = ()=> galleryTrack.scrollBy({ left:  oneItemWidth(), behavior: 'smooth' });
  }

  function renderDiag(){
    const {owner, repo, branch, prefix, path} = STATE;
    const txt = `Kontext: ${owner||'?'}/${repo||'?'}@${branch||'?'}  |  prefix="${prefix||''}"  |  path="${path}"`;
    diagEl.textContent = txt;
  }

  // --- UI events ---
  searchInput.addEventListener('input', ()=>{
    const q = searchInput.value.toLowerCase().trim();
    const showHidden = toggleHidden.checked;
    const rows = Array.from(tbody.querySelectorAll('tr.row'));
    let any=false;
    rows.forEach(r=>{
      const name = (r.dataset.name||'').toLowerCase();
      const hidden = name.startsWith('.');
      const match = !q || name.includes(q);
      const vis = match && (showHidden || !hidden);
      r.style.display = vis? '' : 'none';
      if (vis) any=true;
    });
    if (!any){ tbody.innerHTML = '<tr><td colspan="3" class="empty">Nichts gefunden.</td></tr>'; }
  });

  toggleHidden.addEventListener('change', ()=>{
    searchInput.dispatchEvent(new Event('input'));
  });

  btnUp.addEventListener('click', ()=>{
    const p = STATE.path.replace(/\/+$/,'');
    const up = p.substring(0, p.lastIndexOf('/')) || '/';
    navigateTo(up);
  });

  $('#btnSave').addEventListener('click', ()=>{
    const before = STATE;
    const cfg = saveSettings();
    // Wenn owner/repo/branch/prefix geändert → Gallery neu aufbauen
    if (before.owner !== cfg.owner || before.repo !== cfg.repo || before.branch !== cfg.branch || before.prefix !== cfg.prefix) {
      GALLERY_BUILT = false;
    }
    load(STATE.path||'/');
  });

  $('#btnReset').addEventListener('click', resetSettings);

  window.addEventListener('popstate', (e)=>{
    const p = (e.state && e.state.path) || currentFolderInSite();
    load(p);
  });

  // Diagnostics toggle (Strg+D)
  window.addEventListener('keydown', (ev)=>{
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'd'){
      ev.preventDefault();
      diagEl.style.display = (diagEl.style.display==='none') ? '' : 'none';
    }
  });

  // Init
  (async function init(){
    applySettingsToUI(readSettings());
    const initial = qs.get('p') ? ('/' + qs.get('p').replace(/^\/+|\.+/g,'')) : currentFolderInSite();
    await load(initial);
  })();

})();
</script>
</body>
</html>
