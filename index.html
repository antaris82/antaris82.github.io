<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>antaris82 — GitHub Pages Browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9aa4b2; --card:#10161d; --accent:#2f81f7; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font:14px/1.45 system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,sans-serif; }
    header { padding:16px 20px; border-bottom:1px solid #1e2630; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    header h1 { font-size:18px; margin:0; }
    header .path { color:var(--muted); font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    main { padding:16px 20px; display:grid; grid-template-columns: 1fr; gap:16px; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .controls input[type="text"] { background:#0e141b; color:var(--fg); border:1px solid #26303c; border-radius:8px; padding:8px 10px; min-width:280px; }
    .controls button { background:var(--accent); color:white; border:0; border-radius:8px; padding:8px 12px; cursor:pointer; }
    .stats { color:var(--muted); }
    .card { background:var(--card); border:1px solid #1e2630; border-radius:12px; padding:14px; }
    .flex { display:flex; gap:8px; align-items:center; }
    .grid { display:grid; gap:8px; }
    .list { display:grid; grid-template-columns: 1fr auto auto; gap:6px 8px; align-items:center; }
    .list .head { color:var(--muted); font-weight:600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color:var(--muted); }
    .readme { max-height:280px; overflow:auto; background:#0e141b; border:1px solid #26303c; border-radius:8px; padding:12px; white-space:pre-wrap; }
    a { color:#9cc4ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .gallery { display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:10px; }
    .gallery img, .gallery video { width:100%; height:140px; object-fit:cover; border-radius:10px; border:1px solid #1e2630; background:#0e141b; }
    footer { padding:20px; color:var(--muted); font-size:12px; }
    .license { font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <header>
    <h1>Repo-Browser</h1>
    <div class="path" id="currentPath">/</div>
    <div class="controls">
      <input id="tokenInput" type="text" placeholder="Optional: GitHub Token (?token=... im URL auch möglich)" />
      <button id="reloadBtn">Neu laden</button>
    </div>
    <div class="stats" id="stats"></div>
  </header>

  <main>
    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>README</strong>
        <span class="muted">wird automatisch geladen, falls vorhanden</span>
      </div>
      <div id="readme" class="readme mono">—</div>
    </section>

    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>Dateien & Ordner</strong>
        <span id="cwdLabel" class="muted mono">/</span>
      </div>
      <div class="list" id="listing">
        <div class="head">Pfad/Name</div>
        <div class="head">Typ</div>
        <div class="head">Größe</div>
      </div>
    </section>

    <section class="card grid">
      <div class="flex" style="justify-content:space-between;">
        <strong>Galerie</strong>
        <span class="muted">Zeigt Medien aus dem aktuellen Ordner (ohne <code>background.*</code>)</span>
      </div>
      <div class="gallery" id="gallery"></div>
    </section>

    <section class="card license">
      <div><strong>Lizenz</strong></div>
      <div>Code: MIT License. Nicht-Code (z. B. PDFs, CSV/PNG): CC BY 4.0. © 2025 antaris — Code: MIT; Daten/Abbildungen/Texte (inkl. PDFs): CC BY 4.0.</div>
    </section>
  </main>

  <footer>
    <div>Dieses Frontend lädt bevorzugt <code>manifest.json</code> (falls vorhanden). Fallback: GitHub Contents API.</div>
  </footer>

  <script>
    // ====== Basiskonfiguration ======
    const OWNER = "antaris82";
    const REPO  = "antaris82.github.io";
    const BRANCH = "main";

    // Current "virtueller" Pfad im Repo (für Unterordnernavigation)
    let cwd = decodeURIComponent((new URLSearchParams(location.search)).get("path") || "");
    if (cwd.startsWith("/")) cwd = cwd.slice(1);
    if (cwd.endsWith("/"))  cwd = cwd.slice(0, -1);

    // Token-Verwendung: Query-Param > Eingabefeld
    const urlToken = (new URLSearchParams(location.search)).get("token") || "";
    const tokenInput = document.getElementById("tokenInput");
    if (urlToken) tokenInput.value = urlToken;

    const statsEl = document.getElementById("stats");
    const listingEl = document.getElementById("listing");
    const readmeEl = document.getElementById("readme");
    const galleryEl = document.getElementById("gallery");
    const cwdLabelEl = document.getElementById("cwdLabel");
    const currentPathEl = document.getElementById("currentPath");

    cwdLabelEl.textContent = "/" + (cwd || "");
    currentPathEl.textContent = "/" + (cwd || "");

    // Hilfsfunktionen
    const isMedia = (p) => /\.(png|jpg|jpeg|gif|webp|svg|mp4|webm|ogg)$/i.test(p);
    const isBackground = (name) => /^background\.(png|jpg|jpeg|gif|webp|svg)$/i.test(name);

    function humanBytes(n) {
      const units = ["B","KB","MB","GB","TB"];
      let i = 0, v = Number(n)||0;
      while (v >= 1024 && i < units.length-1) { v /= 1024; i++; }
      return (Math.round(v*10)/10) + " " + units[i];
    }

    function authHeaders() {
      const t = tokenInput.value.trim();
      return t ? { "Authorization": "Bearer " + t } : {};
    }

    function navigateTo(path) {
      const params = new URLSearchParams(location.search);
      if (urlToken && !params.get("token")) params.set("token", urlToken);
      params.set("path", path);
      location.search = params.toString();
    }

    // ====== 1) Erst manifest.json versuchen ======
    async function fetchManifest() {
      try {
        const res = await fetch("/manifest.json", { cache: "no-store" });
        if (!res.ok) return null;
        return await res.json();
      } catch {
        return null;
      }
    }

    // ====== 2) Fallback: GitHub Contents API ======
    // Hole rekursiv alle Dateien (zur Not). Achtung: kann bei großen Repos viele Calls nutzen; Token empfohlen.
    async function fetchAllViaAPI() {
      // Listet einen Ordner via Contents API
      async function listDir(path = "") {
        const api = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(BRANCH)}`;
        const res = await fetch(api, { headers: { ...authHeaders() } });
        if (!res.ok) throw new Error("API error " + res.status);
        return await res.json(); // Array (files/dirs)
      }
      // Wir traversieren rekursiv für ein Vollmanifest
      const acc = [];
      async function walk(path="") {
        const items = await listDir(path);
        for (const it of items) {
          if (it.type === "file") {
            acc.push({ path: it.path, size: it.size ?? 0, sha: it.sha, type: "blob", mode: "100644" });
          } else if (it.type === "dir") {
            await walk(it.path);
          }
        }
      }
      await walk("");
      return acc.sort((a,b)=> a.path.localeCompare(b.path));
    }

    // ====== README laden (falls vorhanden) ======
    async function loadReadme(manifest) {
      // Suche README.* im aktuellen Ordner
      const prefix = cwd ? (cwd + "/") : "";
      const candidates = ["README.md","readme.md","README","Readme.md","README.txt","readme.txt"];
      let readmeEntry = manifest.find(x => x.path.toLowerCase() === (prefix + "readme.md")) ||
                        manifest.find(x => x.path.toLowerCase() === (prefix + "readme"));
      if (!readmeEntry) {
        // alternative Kandidaten prüfen
        for (const name of candidates) {
          const hit = manifest.find(x => x.path === (prefix + name));
          if (hit) { readmeEntry = hit; break; }
        }
      }
      if (!readmeEntry) {
        readmeEl.textContent = "Kein README im aktuellen Ordner gefunden.";
        return;
      }
      try {
        // Raw-URL zu GitHub (ohne Rate-Limits des API-Endpoints)
        const raw = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${readmeEntry.path}`;
        const r = await fetch(raw, { headers: { ...authHeaders() }, cache: "no-store" });
        if (!r.ok) throw new Error("READMERaw error " + r.status);
        let txt = await r.text();
        readmeEl.textContent = txt;
      } catch (e) {
        readmeEl.textContent = "README konnte nicht geladen werden: " + e.message;
      }
    }

    // ====== Listing + Galerie für aktuellen Ordner ======
    function renderFolder(manifest) {
      // Filter manifest auf items im aktuellen Ordner (direkt, nicht rekursiv)
      const prefix = cwd ? (cwd + "/") : "";
      const direct = manifest
        .filter(x => x.path.startsWith(prefix))
        .map(x => ({ ...x, rest: x.path.slice(prefix.length) }))
        .filter(x => x.rest.length > 0 && !x.rest.includes("/")); // nur direkte Kinder

      // Ordner aus den Pfaden ableiten
      const dirsSet = new Set(
        manifest
          .filter(x => x.path.startsWith(prefix))
          .map(x => x.path.slice(prefix.length))
          .filter(x => x.includes("/"))
          .map(x => x.split("/")[0])
      );
      const dirs = Array.from(dirsSet).sort();

      // UI leeren (bis auf Kopfzeile)
      listingEl.innerHTML = `
        <div class="head">Pfad/Name</div>
        <div class="head">Typ</div>
        <div class="head">Größe</div>
      `;

      // "nach oben" Link, falls in Unterordner
      if (cwd) {
        const up = cwd.split("/").slice(0, -1).join("/");
        const row = document.createElement("div");
        row.className = "mono";
        row.style.gridColumn = "1 / span 3";
        row.innerHTML = `<a href="javascript:void(0)" onclick="(${navigateTo.toString()})('${up}')">⬅︎ .. (nach oben)</a>`;
        listingEl.appendChild(row);
      }

      // Ordner rendern
      for (const d of dirs) {
        const rowName = document.createElement("div");
        rowName.className = "mono";
        rowName.innerHTML = `<a href="javascript:void(0)" onclick="(${navigateTo.toString()})('${cwd ? (cwd + '/') : ''}${d}')">📁 ${d}</a>`;
        const rowType = document.createElement("div");
        rowType.textContent = "dir";
        rowType.className = "muted mono";
        const rowSize = document.createElement("div");
        rowSize.textContent = "—";
        rowSize.className = "muted mono";
        listingEl.appendChild(rowName);
        listingEl.appendChild(rowType);
        listingEl.appendChild(rowSize);
      }

      // Dateien rendern
      for (const f of direct.filter(x => x.type === "blob")) {
        const name = f.rest;
        const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${encodeURIComponent(cwd ? (cwd + "/" + name) : name)}`;
        const rowName = document.createElement("div");
        rowName.className = "mono";
        rowName.innerHTML = `📄 <a href="${rawUrl}" target="_blank" rel="noopener">${name}</a>`;
        const rowType = document.createElement("div");
        rowType.textContent = "file";
        rowType.className = "muted mono";
        const rowSize = document.createElement("div");
        rowSize.textContent = humanBytes(f.size);
        rowSize.className = "muted mono";
        listingEl.appendChild(rowName);
        listingEl.appendChild(rowType);
        listingEl.appendChild(rowSize);
      }

      // Galerie rendern (nur Medien im aktuellen Ordner), background.* explizit ausschließen
      galleryEl.innerHTML = "";
      const mediaFiles = direct
        .filter(x => x.type === "blob" && isMedia(x.rest) && !isBackground(x.rest));
      for (const m of mediaFiles) {
        const rawUrl = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${encodeURIComponent(BRANCH)}/${encodeURIComponent(cwd ? (cwd + "/" + m.rest) : m.rest)}`;
        if (/\.(mp4|webm|ogg)$/i.test(m.rest)) {
          const v = document.createElement("video");
          v.src = rawUrl;
          v.controls = true;
          galleryEl.appendChild(v);
        } else {
          const img = document.createElement("img");
          img.src = rawUrl;
          img.alt = m.rest;
          galleryEl.appendChild(img);
        }
      }

      // Stats
      const totalFiles = manifest.filter(x => x.type === "blob").length;
      statsEl.textContent = `Gesamtdateien: ${totalFiles} | Aktueller Ordner: ${dirs.length} Ordner, ${direct.filter(x=>x.type==='blob').length} Dateien`;
    }

    // ====== Bootstrapping ======
    async function boot() {
      document.getElementById("reloadBtn").addEventListener("click", () => location.reload());

      let manifest = await fetchManifest();
      if (!manifest) {
        // Fallback: vollständiges Manifest via API (Token empfohlen)
        try {
          manifest = await fetchAllViaAPI();
        } catch (e) {
          statsEl.textContent = "Fehler beim Laden (API): " + e.message;
          return;
        }
      }

      await loadReadme(manifest);
      renderFolder(manifest);
    }

    boot();
  </script>
</body>
</html>
